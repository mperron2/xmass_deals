"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.typescriptExportDefinition = void 0;
const style_dictionary_1 = __importDefault(require("style-dictionary"));
const sync_1 = __importDefault(require("@prettier/sync"));
const fs = require("fs");
const path = require("path");
const treeWalker_1 = require("../utilities/treeWalker");
const prefixTokens_1 = require("./utilities/prefixTokens");
const { fileHeader } = style_dictionary_1.default.formatHelpers;
/**
 * unquoteTypes
 * @description extract types from designTokenTypes (string with type definitions from file) and replace quoted types "Color" with unquoted Color
 * @param output
 * @param designTokenTypes
 * @returns string with unquoted types
 */
const unquoteTypes = (output, designTokenTypes) => {
    // join types for replacement
    const regex = `"(${['number', 'string', 'any', ...designTokenTypes].join('|')})"`;
    // remove strings
    return output.replace(new RegExp(regex, 'g'), '$1');
};
/**
 * getTokenType
 * @description extract content from token files
 * @param path string
 */
const getTokenType = (tokenTypesPath) => {
    try {
        const designTokenType = fs.readFileSync(path.resolve(tokenTypesPath), { encoding: 'utf-8' });
        return designTokenType;
    }
    catch (e) {
        // eslint-disable-next-line no-console
        throw new Error(`Error trying to load design token type from file "${tokenTypesPath}".`);
    }
};
/**
 * @description throws an error stating the token name, type and invalid value
 * @param token w3cTransformedToken
 */
const invalidTokenValueError = (token) => {
    throw new Error(`Invalid token: "${token.name}" with type "${token.$type}" can not have a value of "${token.value}"`);
};
/**
 * convertPropToType
 * @description return take type attribute and return correct typescript type as string
 * @param type
 * @returns
 */
const convertPropToType = (tree) => {
    if (!Object.prototype.hasOwnProperty.call(tree, 'value')) {
        throw new Error(`Invalid token: ${tree}`);
    }
    switch (tree.$type) {
        case 'color':
            if (typeof tree.value === 'string' && tree.value[0] === '#') {
                return 'ColorHex';
            }
            return invalidTokenValueError(tree);
        case 'dimension':
            if (typeof tree.value === 'string' && tree.value.substring(tree.value.length - 3) === 'rem')
                return 'SizeRem';
            if (typeof tree.value === 'string' && tree.value.substring(tree.value.length - 2) === 'em')
                return 'SizeEm';
            if (typeof tree.value === 'string' && tree.value.substring(tree.value.length - 2) === 'px')
                return 'SizePx';
            return invalidTokenValueError(tree);
        case 'shadow':
            return 'Shadow';
        case 'border':
            return 'Border';
        default:
            if (typeof tree.value === 'number')
                return 'number';
            if (typeof tree.value === 'string')
                return 'string';
            if (typeof tree.value === 'boolean')
                return 'boolean';
            return 'any';
    }
};
/**
 * a valid token node has a `value` property
 * @param item object
 * @returns boolean
 */
const validTokenNode = (item) => {
    return typeof item === 'object' && item !== null && 'value' in item;
};
/**
 * returns a set with every used token type
 * @param item object
 * @param validTypes array, all other types will be removed
 * @returns set of all used token types
 */
const getUsedTokenTypes = (tokens, validTypes) => {
    // using a set to assure every value only exists once
    const usedTypes = new Set();
    // adds type to set
    const callback = (tree) => usedTypes.add(convertPropToType(tree));
    // tree walker adds to usedTypes
    (0, treeWalker_1.treeWalker)(tokens, callback, validTokenNode);
    // clean up types
    for (const type of usedTypes) {
        if (!validTypes.includes(type)) {
            usedTypes.delete(type);
        }
    }
    return usedTypes;
};
/**
 * returns the entire token object structure but instead of token values each token just has a typescript type
 * @param item object
 * @returns object
 */
const getTokenObjectWithTypes = (tokens) => {
    // TODO: FIX typescript issues
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    return (0, treeWalker_1.treeWalker)(tokens, convertPropToType, validTokenNode);
};
/**
 * getTypeDefinition
 * @description returns type definitions as string
 * @param tokens
 * @param moduleName
 * @param tokenTypesPath
 * @returns string
 */
const getTypeDefinition = (tokens, moduleName, tokenTypesPath) => {
    const usedTypes = getUsedTokenTypes(tokens, ['ColorHex', 'Shadow', 'Border', 'SizeEm', 'SizeRem', 'SizePx']);
    const tokenObjectWithTypes = getTokenObjectWithTypes(tokens);
    // get token type declaration from file
    const designTokenTypes = [];
    for (const type of usedTypes) {
        // path to type files without trailing slash
        const typePath = tokenTypesPath.replace(new RegExp(/\/$/, 'g'), '');
        designTokenTypes.push(getTokenType(`${typePath}/${type}.d.ts`));
    }
    // build output
    const output = `${designTokenTypes.join('\n')} 
    export type ${moduleName} = ${JSON.stringify(tokenObjectWithTypes, null, 2)}`;
    // JSON stringify will quote strings, because this is a type we need it unquoted.
    return unquoteTypes(output, [...usedTypes]);
};
/**
 * @description Converts `StyleDictionary.dictionary.tokens` to typescript definition
 * @param arguments [FormatterArguments](https://github.com/amzn/style-dictionary/blob/main/types/Format.d.ts)
 * @returns formatted `string`
 */
const typescriptExportDefinition = ({ dictionary, file, options = {}, platform, }) => {
    // extract options
    const { moduleName = `tokens`, tokenTypesPath = `./src/types/` } = options;
    // add prefix if defined
    const tokens = (0, prefixTokens_1.prefixTokens)(dictionary.tokens, platform);
    // add file header and convert output
    const output = `${fileHeader({ file })}\n${getTypeDefinition(tokens, moduleName, tokenTypesPath)}\n`;
    // return prettified
    return sync_1.default.format(output, { parser: 'typescript', printWidth: 500 });
};
exports.typescriptExportDefinition = typescriptExportDefinition;
