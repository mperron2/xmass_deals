"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.jsonFigma = void 0;
const style_dictionary_1 = __importDefault(require("style-dictionary"));
const sync_1 = __importDefault(require("@prettier/sync"));
const namePathToFigma_1 = require("../transformers/namePathToFigma");
const hexToRgbaFloat_1 = require("../transformers/utilities/hexToRgbaFloat");
const isRgbaFloat_1 = require("../transformers/utilities/isRgbaFloat");
const { sortByReference } = style_dictionary_1.default.formatHelpers;
const isReference = (string) => /^\{([^\\]*)\}$/g.test(string);
const getReference = (dictionary, refString, platform) => {
    var _a;
    if (isReference(refString)) {
        // retrieve reference token
        const refToken = dictionary.getReferences(refString)[0];
        // return full reference
        return [(_a = refToken.attributes) === null || _a === void 0 ? void 0 : _a.collection, (0, namePathToFigma_1.transformNamePathToFigma)(refToken, platform)].filter(Boolean).join('/');
    }
};
const getFigmaType = (type) => {
    const validTypes = {
        color: 'COLOR',
        dimension: 'FLOAT',
        fontWeight: 'FLOAT',
        number: 'FLOAT',
        fontFamily: 'STRING',
    };
    if (type in validTypes)
        return validTypes[type];
    throw new Error(`Invalid type: ${type}`);
};
const shadowToVariables = (name, values, token) => {
    // floatValue
    const floatValue = (property) => ({
        name: `${name}/${property}`,
        value: parseInt(values[property].replace('px', '')),
        type: 'FLOAT',
        scopes: ['EFFECT_FLOAT'],
        mode,
        collection,
        group,
    });
    const { attributes } = token;
    const { mode, collection, group } = attributes || {};
    return [
        floatValue('offsetX'),
        floatValue('offsetY'),
        floatValue('blur'),
        floatValue('spread'),
        {
            name: `${name}/color`,
            value: (0, isRgbaFloat_1.isRgbaFloat)(values.color)
                ? Object.assign(Object.assign({}, values.color), (values.alpha ? { a: values.alpha } : {})) : (0, hexToRgbaFloat_1.hexToRgbaFloat)(values.color, values.alpha),
            type: 'COLOR',
            scopes: ['EFFECT_COLOR'],
            mode,
            collection,
            group,
        },
    ];
};
/**
 * @description Converts `StyleDictionary.dictionary.tokens` to javascript esm (javascript export statement)
 * @param arguments [FormatterArguments](https://github.com/amzn/style-dictionary/blob/main/types/Format.d.ts)
 * @returns formatted `string`
 */
const jsonFigma = ({ dictionary, file: _file, platform }) => {
    // array to store tokens in
    const tokens = [];
    // loop through tokens sorted by reference
    for (const token of dictionary.allTokens.sort(sortByReference(dictionary))) {
        // deconstruct token
        const { attributes, value, $type, comment: description, original, alpha, mix } = token;
        const { mode, collection, scopes, group, codeSyntax } = attributes || {};
        // shadows need to be specifically dealt with
        if ($type === 'shadow') {
            const shadowValues = !Array.isArray(value) ? [value] : value;
            // if only one set of shadow values is present
            if (shadowValues.length === 1) {
                tokens.push(...shadowToVariables(token.name, shadowValues[0], Object.assign(Object.assign({}, token), (platform.mode ? { mode: platform.mode } : {}))));
            }
            else {
                // if multiple shadow sets values are present we need loop through them and add the index to the name
                for (const [index, stepValue] of shadowValues.entries()) {
                    tokens.push(...shadowToVariables(`${token.name}/${index + 1}`, stepValue, Object.assign(Object.assign({}, token), (platform.mode ? { mode: platform.mode } : {}))));
                }
            }
            // other tokens just get added to tokens array
        }
        else {
            tokens.push({
                name: token.name,
                value,
                type: getFigmaType($type),
                alpha,
                isMix: mix ? true : undefined,
                description,
                refId: [collection, token.name].filter(Boolean).join('/'),
                reference: getReference(dictionary, original.value, platform),
                collection,
                mode,
                group,
                scopes,
                codeSyntax,
            });
        }
    }
    // add file header and convert output
    const output = JSON.stringify(tokens, null, 2);
    // return prettified
    return sync_1.default.format(output, { parser: 'json', printWidth: 500 });
};
exports.jsonFigma = jsonFigma;
