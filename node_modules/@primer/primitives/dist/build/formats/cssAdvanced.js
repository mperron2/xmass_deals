"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cssAdvanced = void 0;
const style_dictionary_1 = __importDefault(require("style-dictionary"));
const sync_1 = __importDefault(require("@prettier/sync"));
const { fileHeader, formattedVariables } = style_dictionary_1.default.formatHelpers;
const wrapWithSelector = (css, selector) => {
    // return without selector
    if (selector === false || selector.trim().length === 0)
        return css;
    // return with selector
    return `${selector} { ${css} }`;
};
const cssAdvanced = ({ dictionary: originalDictionary, options = {
    queries: [],
}, file, }) => {
    var _a, _b, _c, _d;
    // get options
    const { outputReferences, formatting } = options;
    // selector
    const selector = ((_a = file.options) === null || _a === void 0 ? void 0 : _a.selector) !== undefined ? file.options.selector : ':root';
    // query extension property
    const queryExtProp = ((_b = file.options) === null || _b === void 0 ? void 0 : _b.queryExtensionProperty) || 'mediaQuery';
    // get queries from file options
    const queries = ((_c = file.options) === null || _c === void 0 ? void 0 : _c.queries) || [
        {
            query: undefined,
            matcher: () => true,
        },
    ];
    // set formatting
    const mergedFormatting = Object.assign({ commentStyle: 'long' }, formatting);
    // clone dictionary
    const dictionary = Object.assign({}, originalDictionary);
    // get queries from tokens
    for (const designToken of dictionary.allTokens) {
        const query = (_d = designToken.$extensions) === null || _d === void 0 ? void 0 : _d[queryExtProp];
        // early abort if query does not exist on token
        if (!query)
            continue;
        // if query exists already from other token
        const currentQueryIndex = queries.findIndex((q) => q.query === query);
        // if query exists
        if (currentQueryIndex > -1) {
            queries[currentQueryIndex] = Object.assign(Object.assign({}, queries[currentQueryIndex]), { matcher: (token) => queries[currentQueryIndex].matcher(token) ||
                    token.$extensions[queryExtProp] === queries[currentQueryIndex].query });
        }
        // if query does not exist
        else {
            queries.push({
                query,
                matcher: (token) => { var _a; return ((_a = token.$extensions) === null || _a === void 0 ? void 0 : _a[queryExtProp]) === query; },
            });
        }
    }
    // add file header
    const output = [fileHeader({ file })];
    // add single theme css
    for (const query of queries) {
        const { query: queryString, matcher } = query;
        // filter tokens to only include the ones that pass the matcher
        const filteredDictionary = Object.assign(Object.assign({}, dictionary), { allTokens: dictionary.allTokens.filter(matcher || (() => true)) });
        // early abort if no matches
        if (!filteredDictionary.allTokens.length)
            continue;
        // add tokens into root
        const css = formattedVariables({
            format: 'css',
            dictionary: filteredDictionary,
            outputReferences,
            formatting: mergedFormatting,
        });
        // wrap css
        const cssWithSelector = wrapWithSelector(css, query.selector !== undefined ? query.selector : selector);
        // add css with or without query
        output.push(queryString ? `${queryString} { ${cssWithSelector} }` : cssWithSelector);
    }
    // return prettified
    return sync_1.default.format(output.join('\n'), { parser: 'css', printWidth: 500 });
};
exports.cssAdvanced = cssAdvanced;
